//==============================================//
//===================REQUIRES===================//
//==============================================//

const fs = require("fs");
const path = require("path");
const JSONC = require("jsonc");


//==============================================//
//==============PARSE CONFIG FILE ==============//
//==============================================//

const config_path = process.argv[2]??"config.json";

if(!fs.existsSync(config_path)){
  console.error(`[Error] (Reading config) ${config_path} do not exists.`);
  process.exit(2);
}

if(!fs.statSync(config_path).isFile()){
  console.error(`[Error] (Reading config) ${config_path} is not a file.`);
  process.exit(2);
}

let config;
try {
  config = JSONC.parse(fs.readFileSync(config_path).toString());
} catch(error){
  console.error(`[Error] (Parsing config) ${error.name}: ${error.message}`);
  process.exit(3);
}

["cryptdevice_uuid", "cryptname", "layers", "input"].every(key=>{
  if(key in config) return true;

  console.error(`[Error] (Parsing config) "${key}" is not found in {}`);
  process.exit(3);
});

//==============================================//
//================CREATE CFG.RS ================//
//==============================================//

let out = `// WARNING: DO NOT EDIT THIS FILE. THIS IS AUTO GENERATED.
// USE BUILDER SCRIPT INSTEAD.

use crate::layer::{Layer, Position};

pub const LAYERS: [Layer;${config.layers.length}] = [`;

//==================FUNCTIONS ==================//
function getPosition(position, flip){
  if(typeof(position) === "number") return {
    numerator: 0,
    denominator: 0,
    absolute: Math.round(position),
    flip
  };
  if(typeof(position) === "string"){
    let i = position.indexOf(":");
    if(i === -1){
      i = position.indexOf("/");
      if(i === -1) throw Error(`The string value must include ':' or "/": "${position}"`);
    }
    let numerator = parseInt(position.substring(0,i));
    if(isNaN(numerator)) throw Error(`The numerator is not a number: "${position}"`);
    let denominator = parseInt(position.substring(i+1));
    if(isNaN(denominator)) throw Error(`The denominator is not a number: "${position}"`);
    if(denominator===0) throw Error(`The denominator can not be zero: "${position}"`);
    return {
      numerator: position.numerator,
      denominator: position.denominator,
      absolute: 0,
        flip
    };
  }
  throw Error(`Can not parse the value: ${position}`);
}

function calc_pos(position,colOrRow){
  position = getPosition(position, false);
  if(position.denominator===0) return position.absolute;
  return Math.round(position.numerator*colOrRow/position.denominator);
}

//TODO: supports only [m
const ansiEnds = Array.from("ABCDEFGHJKmSTf");
function getAnsiLength(str) {
  let out = 0;
  for(let i=0; i<str.length; i++) {
    const c = str[i];
    if(c === '\x1B') {
      while(i<str.length) {
        i++;
        const c2 = str[i];
        if(ansiEnds.some(end => end === c2)) {
          /*if(c2 === 'm')*/ break;
        }
      }
    } else {
      out++;
    }
  }
  return out;
}

function getSize(ascii){
  const splited = ascii.split("\n");
  return {
    splited,
    x: Math.max(...splited.map(getAnsiLength)),
    y: splited.length
  };
}

function parsePosition(position, key){
  if(key in position) return getPosition(position[key], false);
  return getPosition(position["-"+key], true);
}

function parseOrigin(origin, key, size){
  if(key in origin) return calc_pos(origin[key], size);
  return size-1-calc_pos(origin["-"+key], size);
}

function makeSafety(str){
  return str.replaceAll("\\","\\\\").replaceAll("\0","\\0").replaceAll("\x1B","\\x1B").replaceAll("\"","\\\"");
}

//=====================MAIN=====================//
for(let i=0;i<config.layers.length;i++){
  const layer = config.layers[i];
  const {splited, size, comment} = (()=>{
    let ascii, comment;
    if("raw" in layer){
      ascii = layer.raw;
      comment = "raw";
    }else if("file" in layer){
      
      const absolute_path = path.join(path.dirname(config_path),layer.file);
      comment = `file: ${layer.file}`;
      
      if(!fs.existsSync(absolute_path)){
        console.error(`[Error] (Creating cfg.rs: layers[${i}]) ${layer.file} do not exists.`);
        process.exit(4);
      }

      if(!fs.statSync(absolute_path).isFile()){
        console.error(`[Error] (Creating cfg.rs: layers[${i}]) ${layer.file} is not a file.`);
        process.exit(4);
      }

      ascii = fs.readFileSync(absolute_path).toString();
    }else{
      console.error(`[Error] (Creating cfg.rs: layers[${i}]) neither 'raw' nor 'file' is found in layers[${i}].`);
      process.exit(3);
    }
    const raw = getSize(ascii);
    return {
      splited: raw.splited,
      size: {x: raw.x, y: raw.y},
      comment
    };
  })();
  let orix, oriy, posx, posy;

  try{
    orix = parseOrigin(layer.origin, "x", size.x);
    oriy = parseOrigin(layer.origin, "y", size.y);
  }catch(error){
    console.error(`[Error] (Creating cfg.rs: layers[${i}].origin) ${error.message}`);
    process.exit(3);
  }

  try{
    posx = parsePosition(layer.position,"x");
    posy = parsePosition(layer.position,"y");
  }catch(error){
    console.error(`[Error] (Creating cfg.rs: layers[${i}].position) ${error.message}`);
    process.exit(3);
  }

  out += `
    // ${comment}
    Layer {
        ascii: &[
${splited.map(i => '            "'+makeSafety(i)+'"').join(",\n")}
        ],
        origin: (${orix},${oriy}),
        position: (Position{
            numerator: ${posx.numerator},
            denominator: ${posx.denominator},
            absolute: ${posx.absolute},
            flip: ${posx.flip}
        },
        Position{
            numerator: ${posy.numerator},
            denominator: ${posy.denominator},
            absolute: ${posy.absolute},
            flip: ${posy.flip}
        })
    },`;
}
out += "\n];\n";

let input_pos, input_left, input_right;


try{
  input_pos = parsePosition(config.input, "position");
  input_left = parsePosition(config.input, "left_padding");
  input_right = parsePosition(config.input, "right_padding");
}catch(error){
  console.error(`[Error] (Creating cfg.rs: input) ${error.message}. Check 'position'(or '-position'), 'left_padding' and 'right_padding' exist.`);
  process.exit(3);
}


if (input_left.flip) {
  console.error("[ERROR] (Creating cfg.rs) 'input.left_padding' cannot be fliped. change 'input.-left_padding' to 'input.left_padding'");
  process.exit(4);
}
if (input_right.flip) {
  console.error("[ERROR] (Creating cfg.rs) 'input.right_padding' cannot be fliped. change 'input.-right_padding' to 'input.right_padding'");
  process.exit(4);
}

out+=`
pub const INPUT_LEFT: Position = Position {
    numerator: ${input_left.numerator},
    denominator: ${input_left.denominator},
    absolute: ${input_left.absolute},
    flip: false
};

pub const INPUT_RIGHT: Position = Position {
    numerator: ${input_right.numerator},
    denominator: ${input_right.denominator},
    absolute: ${input_right.absolute},
    flip: true
};

pub const INPUT_POS: Position = Position {
    numerator: ${input_pos.numerator},
    denominator: ${input_pos.denominator},
    absolute: ${input_pos.absolute},
    flip: ${input_pos.flip}
};

pub const DEBUG: bool = ${config.debug??false};

pub const CRYPTDEVICE_UUID: &str = "${makeSafety(config.cryptdevice_uuid)}";
pub const CRYPTNAME: &str = "${makeSafety(config.cryptname)}";

pub const TRY_TIMES: i32 = ${(()=>{
  //TODO
  if("try_times" in config){
    if(typeof config.try_times !== "number"){
      console.error(`[Error] (Creating cfg.rs) 'try_times' must be integer. (given: ${typeof config.try_times})`);
      process.exit(3);
    }
    return config.try_times;
  }
  return 30;
})()};
pub const TRY_INTERVAL: u64 = ${(()=>{
  //TODO
  if("try_interval" in config){
    if(typeof config.try_interval !== "number"){
      console.error(`[Error] (Creating cfg.rs) 'try_interval' must be integer. (given: ${typeof config.try_interval})`);
      process.exit(3);
    }
    return config.try_interval;
  }
  return 100;
})()};
`;

console.log(out);
